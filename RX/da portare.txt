unsigned int cicli_inattivo;                // Usata per contare n° interrupt di inattività
unsigned int indice_test;                   // Usata come indice nel test del canale
unsigned int conta_disturbi;                // Usata per contare i disturbi nel test del canale

char i,                                     // Usata per ciclo for in interrupt_low() e in change()
     refr_dato,                             // Usata in scr_ora() per ciclo for e per preparazione dato
     ricevuto, ricevuto_CT,                 // Usate per contenere il byte ricevuto e il byte di controllo

     int_cont,                              // Usata per il conto degli interrupt del timer
     conta_lampeggi,                        // Usata in scr_ora() per regolare la frequenza del lampeggio in impostazione tempo
     percentuale,                           // Percentuale di disturbo del canale
     
     first_bit_fail_count,                  // conta gli 0 nel primo bit
     acq_cnt,                               // Usata in acq() per contare e ritornare il numero degli 1 letti nel bit
     acq_i,                                 // Usata in acq() per il ciclo for
     change_exc,                            // Usata in change() per scambiare i byte quando si fa cambio campo
     slvs_chr,                              // Usata in salvaschermo() per l'animazione di standby per controllare ed aggiornare i punti luminosi
     slvs_flag,                             // Usata per i flag per la chiamata di salvaschermo()
                                            //       B0=iniziale    B1=per standby
     temp_chr,                              // Usata nella debug mode in scr_ora() per formattare ed aggiornare i display con informazioni varie
     ch_temp_chr;                           // Usata per elaborare i dati nella routine change()
     

void scr_ora() {                            // Routine di aggiornamento dei dati
    if (DEBUG_MODE) {
        wire_send(decod('d'));
        wire_send(decod('e'));
        wire_send(decod('b'));
        wire_send(decod('g'));
        refr_tempo();
                
        wire_send(flagr);                   // set
        wire_send(0x06);                    // centinaia
        asm {
        SWAPF _ricevuto+0,w
        ANDLW 0x0F
        MOVWF _temp_chr+0
        }
        wire_send(decod(temp_chr));         // decine
        asm {
        MOVF _ricevuto+0,w
        ANDLW 0x0F
        MOVWF _temp_chr+0
        }
        wire_send(decod(temp_chr));         // unità
        refr_loc();

        wire_send(decod(first_bit_fail_count));
        wire_send(0x06);
        asm {
        SWAPF _ricevuto_CT+0,w
        ANDLW 0x0F
        MOVWF _temp_chr+0
        }
        wire_send(decod(temp_chr));
        asm {
        MOVF _ricevuto_CT+0,w
        ANDLW 0x0F
        MOVWF _temp_chr+0
        }
        wire_send(decod(temp_chr));
        refr_ospiti();
        
        FARE_REFRESH_COMPLETO=1;
        REFRESH_REQ=0;
        return;
    }

    if (IMPOSTA_TEMPO==1) {                 // Se sto impostando il tempo
        FARE_REFRESH_COMPLETO=1;            // serve poi un refresh completo
        
        for (refr_dato=0; refr_dato<4; refr_dato++) wire_send(0x40);
        refr_loc();
        refr_ospiti();

        if (AGGIORNATO==1) {                // regolo il lampeggio del tempo
            if (conta_lampeggi>BLINK_INTERVAL) {
                conta_lampeggi=0;
                AGGIORNATO=0;
            }
            else conta_lampeggi++;

            wire_send(decod(ora[3]));
            wire_send(decod(ora[2]));
            wire_send(decod(ora[1]));
            wire_send(decod(ora[0]));
            refr_tempo();
        }
        else {
            if (conta_lampeggi>BLINK_INTERVAL) {
                conta_lampeggi=0;
                AGGIORNATO=1;
            }
            else conta_lampeggi++;

            wire_send(0x00);
            wire_send(0x00);
            wire_send(0x00);
            wire_send(0x00);
            refr_tempo();
        }
    }
    else {
        AGGIORNATO=0;                       // se ho richiesto il refresh perchè
                                            // a fine impostazione non ho
                                            // aggiornato, ora annullo il flag di
                                            // non aggiornamento
        FARE_REFRESH_COMPLETO=0;            // non serve fare un refresh completo
       
        wire_send(decod(set_loc));          // Refresh dei locali
        refr_dato=0x00;
        if (pt_loc_cent==1)  refr_dato=0x06;
        if (P7F_LOC) refr_dato.B5=1;
        if (P1_LOC)  refr_dato.B4=1;
        if (P2_LOC)  refr_dato.B3=1;
        wire_send(refr_dato);
        if (pt_loc_dec>0 || pt_loc_cent==1)    wire_send(decod(pt_loc_dec));
        else                 wire_send(0x00);
        wire_send(decod(pt_loc_un));
        refr_loc();
                                            // Refresh degli ospiti
        wire_send(decod(set_osp));
        refr_dato=0x00;
        if (pt_osp_cent==1)  refr_dato=0x06;
        if (P7F_OSP) refr_dato.B3=1;
        if (P1_OSP)  refr_dato.B4=1;
        if (P2_OSP)  refr_dato.B5=1;
        wire_send(refr_dato);
        if (pt_osp_dec>0 || pt_osp_cent==1)    wire_send(decod(pt_osp_dec));
        else                 wire_send(0x00);
        wire_send(decod(pt_osp_un));
        refr_ospiti();

                                            // Refresh del tempo
        if (ora[3]>0)    wire_send(decod(ora[3]));
        else             wire_send(0x00);
        wire_send(decod(ora[2]));
        wire_send(decod(ora[1]));
        wire_send(decod(ora[0]));
        refr_tempo();
    }

    // Annullo il refresh
    REFRESH_REQ=0;
}

void change(char codice) {
    if (codice==_CD_CHANNEL_TEST && DEBUG_MODE==0 && TEMPO_AVVIATO==0) {
        INTCON.GIEH=0;
        INTCON.GIEL=0;
    
        for (i=0; i<4; i++)                 // eseguo test del canale
            IRS_wire_send(0x00);
        refr_loc(); refr_ospiti();

        IRS_wire_send(IRS_decod('a'));
        IRS_wire_send(IRS_decod('t'));
        IRS_wire_send(IRS_decod('t'));
        IRS_wire_send(0x00);
        refr_tempo();
        
        conta_disturbi=0;
        for (indice_test=0; indice_test<30000; indice_test++) {
            if (DATA_IN_PIN==1) conta_disturbi++;
            Delay_us(100);                  // in totale 100us*30000=3 secondi
        }
        
        percentuale=255.0*conta_disturbi/30000.0;

        for (i=0; i<4; i++)
            IRS_wire_send(0x40);
        refr_ospiti(); refr_tempo();

        IRS_wire_send(0x00);                    // set
        IRS_wire_send(0x00);                    // centinaia
        asm {
        MOVF _percentuale+0,w
        ANDLW 0xF0
        MOVWF _ch_temp_chr+0
        SWAPF _ch_temp_chr+0,f
        }
        IRS_wire_send(IRS_decod(ch_temp_chr));
        asm {
        MOVF _percentuale+0,w
        ANDLW 0x0F
        MOVWF _ch_temp_chr+0
        }
        IRS_wire_send(IRS_decod(ch_temp_chr));
        refr_loc(); 
        
        Delay_ms(3000);

        INTCON.GIEH=1;
        INTCON.GIEL=1;
        return;
    }
    return;
}

void interrupt() {                          // Routine di interrupt alta priorità
    if (INTCON.T0IF) {
        INTCON.T0IF=0;
        TMR0L=12;
        if (IMPOSTA_TEMPO==1 || FARE_REFRESH_COMPLETO) { REFRESH_REQ=1; }   
                                           // Richiedo il refresh se il tempo è
                                           // in impostazione o non ho aggiornato
                                           // l'ultima volta
        if (IN_SALVASCHERMO==0 && TEMPO_AVVIATO==0 && DEBUG_MODE==0) {
            cicli_inattivo++;
            if (cicli_inattivo>MAX_CICLI_INATTIVI) {
                cicli_inattivo=0;
                slvs_flag=SL_INATTIVO;
                IN_SALVASCHERMO=1;
            }
        }
        
        if (TEMPO_AVVIATO==0) goto fine_ciclo;
        int_cont++;
        if (int_cont<16)      goto fine_ciclo;
        TMR0L=3;
        REFRESH_REQ=1;
        int_cont=0;

        ora[0]=ora[0]-1;
        if (ora[0]!=0xFF) goto fine_ciclo
        ora[0]=9;
        ora[1]=ora[1]-1;
        if (ora[1]!=0xFF) goto fine_ciclo
        ora[1]=5;
        ora[2]=ora[2]-1;
        if (ora[2]!=0xFF) goto fine_ciclo
        ora[2]=9;
        ora[3]=ora[3]-1;
        if (ora[3]!=0xFF) goto fine_ciclo
        ora[3]=5;

        reset_time();
        if (USA_CLAXON) {
            CLAXON_CMD_PIN=1;
            Delay_ms(500);
            CLAXON_CMD_PIN=0;
            Delay_ms(250);
            CLAXON_CMD_PIN=1;
            Delay_ms(1000);
            CLAXON_CMD_PIN=0;
        }
    }
    
    fine_ciclo: return;
    }
                                         // -----------------
void salvaschermo() {                    // Routine di gestione del salvaschermo, 
                                         // richiede impostazione dei flag prima
    char slvs_cnt;                       // esempio: IN_SALVASCHERMO=1;
                                         //          slvs_flag=SL_INIZIALE;
                                         //          salvaschermo();
    int slvs_cnt2;                       // usata nei for per le temporizzazioni
    
    DATA_PIN=1;                          // spengo tutti i display
    for (slvs_cnt=0; slvs_cnt<32; slvs_cnt++) {
        CLOCK_PIN=1;
        Delay_us(CLOCK_US_ON);
        CLOCK_PIN=0;
        Delay_us(CLOCK_US_OFF);
    }
    refr_loc(); refr_ospiti(); refr_tempo();
    Delay_ms(100);
    
    if (slvs_flag==SL_INATTIVO) {        // se è per inattività
        while (IN_SALVASCHERMO) {

            wire_send(0x00); wire_send(0b00001000);
            wire_send(0x00); wire_send(0x00);
            refr_ospiti();
            wire_send(0x00); wire_send(0x00);
            wire_send(0x00); wire_send(0x00);
            refr_loc();      refr_tempo();
            
            for (slvs_cnt2=0; slvs_cnt2<200; slvs_cnt2++) {
                Delay_ms(1);
                if (IN_SALVASCHERMO==0) goto slvs_out;
            }
            
            wire_send(0x00); wire_send(0x00);
            wire_send(0x00); wire_send(0x00);
            refr_ospiti(); refr_loc(); refr_tempo();
            
            for (slvs_cnt2=0; slvs_cnt2<800; slvs_cnt2++) {
                Delay_ms(1);
                if (IN_SALVASCHERMO==0) goto slvs_out;
            }
        }
    }
    else {                               // se è ordinato per test dei segmenti
        DATA_PIN=1;
        while (IN_SALVASCHERMO) {
            if (DATA_PIN==1) DATA_PIN=0;
            else             DATA_PIN=1;
            
            for (slvs_cnt=0; slvs_cnt<32; slvs_cnt++) {
                CLOCK_PIN=1;
                Delay_us(CLOCK_US_ON);
                CLOCK_PIN=0;
                Delay_us(CLOCK_US_OFF);
                refr_loc(); refr_ospiti();
                if (slvs_flag.B0==0) refr_tempo();
                for (slvs_cnt2=0; slvs_cnt2<80; slvs_cnt2++) {
                    Delay_us(500);
                    if (IN_SALVASCHERMO==0) goto slvs_out;
                }
            }
        }
    }
    slvs_out:
    return;
}

void main() 
{
    if (RCON.RI==0) {                       // per esecuzione di RESET volontario
        wire_send(0x40);wire_send(0x40);wire_send(0x40);wire_send(0x40);
        refr_loc(); refr_ospiti(); refr_tempo();
        Delay_ms(1000);
        REFRESH_REQ=1;
    }
    else {
        for (i=0; i<4; i++)                 // eseguo test del canale
            wire_send(0x00);
        refr_loc(); refr_ospiti();
    }
    
    USA_CLAXON=0;                           // Leggo configurazione claxon
    if (EEProm_Read(EEPROM_CLAXON_CELL)==0x01) {
        USA_CLAXON=1;
        wire_send(decod(5));
        wire_send(0x00);
        wire_send(decod('o'));
        wire_send(decod('n'));
        refr_tempo();
        Delay_ms(2500);
    }
    else {
        wire_send(decod(5));
        wire_send(decod('o'));
        wire_send(decod('f'));
        wire_send(decod('f'));
        refr_tempo();
        Delay_ms(750);
    }
    
    if (RCON.RI==1) {
        RCON.RI=1;
        slvs_flag=SL_ORDINATO;
        IN_SALVASCHERMO=1;
        salvaschermo();
    }
    
    while (1) {
        if (REFRESH_REQ==1) {
            scr_ora();
            while (DATA_IN_PIN==1) asm NOP
        }
        if (IN_SALVASCHERMO) salvaschermo();   // se serve il salvaschermo
    }
}